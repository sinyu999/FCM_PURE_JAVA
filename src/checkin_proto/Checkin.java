// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: checkin.proto

package checkin_proto;

public final class Checkin {
  private Checkin() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface GservicesSettingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:checkin_proto.GservicesSetting)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes name = 1;</code>
     */
    boolean hasName();
    /**
     * <code>required bytes name = 1;</code>
     */
    com.google.protobuf.ByteString getName();

    /**
     * <code>required bytes value = 2;</code>
     */
    boolean hasValue();
    /**
     * <code>required bytes value = 2;</code>
     */
    com.google.protobuf.ByteString getValue();
  }
  /**
   * <pre>
   * A concrete name/value pair sent to the device's Gservices database.
   * </pre>
   *
   * Protobuf type {@code checkin_proto.GservicesSetting}
   */
  public  static final class GservicesSetting extends
      com.google.protobuf.GeneratedMessageLite<
          GservicesSetting, GservicesSetting.Builder> implements
      // @@protoc_insertion_point(message_implements:checkin_proto.GservicesSetting)
      GservicesSettingOrBuilder {
    private GservicesSetting() {
      name_ = com.google.protobuf.ByteString.EMPTY;
      value_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString name_;
    /**
     * <code>required bytes name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required bytes name = 1;</code>
     */
    public com.google.protobuf.ByteString getName() {
      return name_;
    }
    /**
     * <code>required bytes name = 1;</code>
     */
    private void setName(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>required bytes name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString value_;
    /**
     * <code>required bytes value = 2;</code>
     */
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required bytes value = 2;</code>
     */
    public com.google.protobuf.ByteString getValue() {
      return value_;
    }
    /**
     * <code>required bytes value = 2;</code>
     */
    private void setValue(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      value_ = value;
    }
    /**
     * <code>required bytes value = 2;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      value_ = getDefaultInstance().getValue();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, value_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, value_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.GservicesSetting parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.GservicesSetting parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.GservicesSetting parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(checkin_proto.Checkin.GservicesSetting prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A concrete name/value pair sent to the device's Gservices database.
     * </pre>
     *
     * Protobuf type {@code checkin_proto.GservicesSetting}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          checkin_proto.Checkin.GservicesSetting, Builder> implements
        // @@protoc_insertion_point(builder_implements:checkin_proto.GservicesSetting)
        checkin_proto.Checkin.GservicesSettingOrBuilder {
      // Construct using checkin_proto.Checkin.GservicesSetting.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes name = 1;</code>
       */
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>required bytes name = 1;</code>
       */
      public com.google.protobuf.ByteString getName() {
        return instance.getName();
      }
      /**
       * <code>required bytes name = 1;</code>
       */
      public Builder setName(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>required bytes name = 1;</code>
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }

      /**
       * <code>required bytes value = 2;</code>
       */
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <code>required bytes value = 2;</code>
       */
      public com.google.protobuf.ByteString getValue() {
        return instance.getValue();
      }
      /**
       * <code>required bytes value = 2;</code>
       */
      public Builder setValue(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <code>required bytes value = 2;</code>
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:checkin_proto.GservicesSetting)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new checkin_proto.Checkin.GservicesSetting();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasName()) {
            return null;
          }
          if (!hasValue()) {
            return null;
          }
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          checkin_proto.Checkin.GservicesSetting other = (checkin_proto.Checkin.GservicesSetting) arg1;
          name_ = visitor.visitByteString(
              hasName(), name_,
              other.hasName(), other.name_);
          value_ = visitor.visitByteString(
              hasValue(), value_,
              other.hasValue(), other.value_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  name_ = input.readBytes();
                  break;
                }
                case 18: {
                  bitField0_ |= 0x00000002;
                  value_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (checkin_proto.Checkin.GservicesSetting.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:checkin_proto.GservicesSetting)
    private static final checkin_proto.Checkin.GservicesSetting DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new GservicesSetting();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static checkin_proto.Checkin.GservicesSetting getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GservicesSetting> PARSER;

    public static com.google.protobuf.Parser<GservicesSetting> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AndroidCheckinRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:checkin_proto.AndroidCheckinRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    boolean hasImei();
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    java.lang.String getImei();
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    com.google.protobuf.ByteString
        getImeiBytes();

    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    boolean hasMeid();
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    java.lang.String getMeid();
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    com.google.protobuf.ByteString
        getMeidBytes();

    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    java.util.List<java.lang.String>
        getMacAddrList();
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    int getMacAddrCount();
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    java.lang.String getMacAddr(int index);
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    com.google.protobuf.ByteString
        getMacAddrBytes(int index);

    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    java.util.List<java.lang.String>
        getMacAddrTypeList();
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    int getMacAddrTypeCount();
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    java.lang.String getMacAddrType(int index);
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    com.google.protobuf.ByteString
        getMacAddrTypeBytes(int index);

    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    boolean hasSerialNumber();
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    java.lang.String getSerialNumber();
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    com.google.protobuf.ByteString
        getSerialNumberBytes();

    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    boolean hasEsn();
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    java.lang.String getEsn();
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    com.google.protobuf.ByteString
        getEsnBytes();

    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    boolean hasId();
    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    long getId();

    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    boolean hasLoggingId();
    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    long getLoggingId();

    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    boolean hasDigest();
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    java.lang.String getDigest();
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    com.google.protobuf.ByteString
        getDigestBytes();

    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    boolean hasLocale();
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    java.lang.String getLocale();
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    com.google.protobuf.ByteString
        getLocaleBytes();

    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    boolean hasCheckin();
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    checkin_proto.AndroidCheckin.AndroidCheckinProto getCheckin();

    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    boolean hasDesiredBuild();
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    java.lang.String getDesiredBuild();
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    com.google.protobuf.ByteString
        getDesiredBuildBytes();

    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    boolean hasMarketCheckin();
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    java.lang.String getMarketCheckin();
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    com.google.protobuf.ByteString
        getMarketCheckinBytes();

    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    java.util.List<java.lang.String>
        getAccountCookieList();
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    int getAccountCookieCount();
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    java.lang.String getAccountCookie(int index);
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    com.google.protobuf.ByteString
        getAccountCookieBytes(int index);

    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    boolean hasTimeZone();
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    java.lang.String getTimeZone();
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    com.google.protobuf.ByteString
        getTimeZoneBytes();

    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    boolean hasSecurityToken();
    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    long getSecurityToken();

    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    boolean hasVersion();
    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    int getVersion();

    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    java.util.List<java.lang.String>
        getOtaCertList();
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    int getOtaCertCount();
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    java.lang.String getOtaCert(int index);
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    com.google.protobuf.ByteString
        getOtaCertBytes(int index);

    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    boolean hasFragment();
    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    int getFragment();

    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    boolean hasUserName();
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    java.lang.String getUserName();
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    com.google.protobuf.ByteString
        getUserNameBytes();

    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    boolean hasUserSerialNumber();
    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    int getUserSerialNumber();
  }
  /**
   * <pre>
   * Devices send this every few hours to tell us how they're doing.
   * </pre>
   *
   * Protobuf type {@code checkin_proto.AndroidCheckinRequest}
   */
  public  static final class AndroidCheckinRequest extends
      com.google.protobuf.GeneratedMessageLite<
          AndroidCheckinRequest, AndroidCheckinRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:checkin_proto.AndroidCheckinRequest)
      AndroidCheckinRequestOrBuilder {
    private AndroidCheckinRequest() {
      imei_ = "";
      meid_ = "";
      macAddr_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      macAddrType_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      serialNumber_ = "";
      esn_ = "";
      digest_ = "";
      locale_ = "";
      desiredBuild_ = "";
      marketCheckin_ = "";
      accountCookie_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      timeZone_ = "";
      otaCert_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      userName_ = "";
    }
    private int bitField0_;
    public static final int IMEI_FIELD_NUMBER = 1;
    private java.lang.String imei_;
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    public boolean hasImei() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    public java.lang.String getImei() {
      return imei_;
    }
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    public com.google.protobuf.ByteString
        getImeiBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(imei_);
    }
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    private void setImei(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      imei_ = value;
    }
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    private void clearImei() {
      bitField0_ = (bitField0_ & ~0x00000001);
      imei_ = getDefaultInstance().getImei();
    }
    /**
     * <pre>
     * IMEI (used by GSM phones) is sent and stored as 15 decimal
     * digits; the 15th is a check digit.
     * </pre>
     *
     * <code>optional string imei = 1;</code>
     */
    private void setImeiBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      imei_ = value.toStringUtf8();
    }

    public static final int MEID_FIELD_NUMBER = 10;
    private java.lang.String meid_;
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    public boolean hasMeid() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    public java.lang.String getMeid() {
      return meid_;
    }
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    public com.google.protobuf.ByteString
        getMeidBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(meid_);
    }
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    private void setMeid(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      meid_ = value;
    }
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    private void clearMeid() {
      bitField0_ = (bitField0_ & ~0x00000002);
      meid_ = getDefaultInstance().getMeid();
    }
    /**
     * <pre>
     * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
     * digits (no check digit).
     * </pre>
     *
     * <code>optional string meid = 10;</code>
     */
    private void setMeidBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      meid_ = value.toStringUtf8();
    }

    public static final int MAC_ADDR_FIELD_NUMBER = 9;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> macAddr_;
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    public java.util.List<java.lang.String> getMacAddrList() {
      return macAddr_;
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    public int getMacAddrCount() {
      return macAddr_.size();
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    public java.lang.String getMacAddr(int index) {
      return macAddr_.get(index);
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    public com.google.protobuf.ByteString
        getMacAddrBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          macAddr_.get(index));
    }
    private void ensureMacAddrIsMutable() {
      if (!macAddr_.isModifiable()) {
        macAddr_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(macAddr_);
       }
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    private void setMacAddr(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrIsMutable();
      macAddr_.set(index, value);
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    private void addMacAddr(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrIsMutable();
      macAddr_.add(value);
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    private void addAllMacAddr(
        java.lang.Iterable<java.lang.String> values) {
      ensureMacAddrIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, macAddr_);
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    private void clearMacAddr() {
      macAddr_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * MAC address (used by non-phone devices).  12 hexadecimal digits;
     * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
     * </pre>
     *
     * <code>repeated string mac_addr = 9;</code>
     */
    private void addMacAddrBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrIsMutable();
      macAddr_.add(value.toStringUtf8());
    }

    public static final int MAC_ADDR_TYPE_FIELD_NUMBER = 19;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> macAddrType_;
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    public java.util.List<java.lang.String> getMacAddrTypeList() {
      return macAddrType_;
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    public int getMacAddrTypeCount() {
      return macAddrType_.size();
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    public java.lang.String getMacAddrType(int index) {
      return macAddrType_.get(index);
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    public com.google.protobuf.ByteString
        getMacAddrTypeBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          macAddrType_.get(index));
    }
    private void ensureMacAddrTypeIsMutable() {
      if (!macAddrType_.isModifiable()) {
        macAddrType_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(macAddrType_);
       }
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    private void setMacAddrType(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrTypeIsMutable();
      macAddrType_.set(index, value);
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    private void addMacAddrType(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrTypeIsMutable();
      macAddrType_.add(value);
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    private void addAllMacAddrType(
        java.lang.Iterable<java.lang.String> values) {
      ensureMacAddrTypeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, macAddrType_);
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    private void clearMacAddrType() {
      macAddrType_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * An array parallel to mac_addr, describing the type of interface.
     * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
     * not present, "wifi" is assumed.
     * </pre>
     *
     * <code>repeated string mac_addr_type = 19;</code>
     */
    private void addMacAddrTypeBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureMacAddrTypeIsMutable();
      macAddrType_.add(value.toStringUtf8());
    }

    public static final int SERIAL_NUMBER_FIELD_NUMBER = 16;
    private java.lang.String serialNumber_;
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    public boolean hasSerialNumber() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    public java.lang.String getSerialNumber() {
      return serialNumber_;
    }
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    public com.google.protobuf.ByteString
        getSerialNumberBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(serialNumber_);
    }
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    private void setSerialNumber(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      serialNumber_ = value;
    }
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    private void clearSerialNumber() {
      bitField0_ = (bitField0_ & ~0x00000004);
      serialNumber_ = getDefaultInstance().getSerialNumber();
    }
    /**
     * <pre>
     * Serial number (a manufacturer-defined unique hardware
     * identifier).  Alphanumeric, case-insensitive.
     * </pre>
     *
     * <code>optional string serial_number = 16;</code>
     */
    private void setSerialNumberBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      serialNumber_ = value.toStringUtf8();
    }

    public static final int ESN_FIELD_NUMBER = 17;
    private java.lang.String esn_;
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    public boolean hasEsn() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    public java.lang.String getEsn() {
      return esn_;
    }
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    public com.google.protobuf.ByteString
        getEsnBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(esn_);
    }
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    private void setEsn(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
      esn_ = value;
    }
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    private void clearEsn() {
      bitField0_ = (bitField0_ & ~0x00000008);
      esn_ = getDefaultInstance().getEsn();
    }
    /**
     * <pre>
     * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
     * </pre>
     *
     * <code>optional string esn = 17;</code>
     */
    private void setEsnBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
      esn_ = value.toStringUtf8();
    }

    public static final int ID_FIELD_NUMBER = 2;
    private long id_;
    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    public long getId() {
      return id_;
    }
    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    private void setId(long value) {
      bitField0_ |= 0x00000010;
      id_ = value;
    }
    /**
     * <pre>
     * Android device ID, not logged
     * </pre>
     *
     * <code>optional int64 id = 2;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000010);
      id_ = 0L;
    }

    public static final int LOGGING_ID_FIELD_NUMBER = 7;
    private long loggingId_;
    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    public boolean hasLoggingId() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    public long getLoggingId() {
      return loggingId_;
    }
    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    private void setLoggingId(long value) {
      bitField0_ |= 0x00000020;
      loggingId_ = value;
    }
    /**
     * <pre>
     * Pseudonymous logging ID for Sawmill
     * </pre>
     *
     * <code>optional int64 logging_id = 7;</code>
     */
    private void clearLoggingId() {
      bitField0_ = (bitField0_ & ~0x00000020);
      loggingId_ = 0L;
    }

    public static final int DIGEST_FIELD_NUMBER = 3;
    private java.lang.String digest_;
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    public boolean hasDigest() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    public java.lang.String getDigest() {
      return digest_;
    }
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    public com.google.protobuf.ByteString
        getDigestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(digest_);
    }
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    private void setDigest(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
      digest_ = value;
    }
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    private void clearDigest() {
      bitField0_ = (bitField0_ & ~0x00000040);
      digest_ = getDefaultInstance().getDigest();
    }
    /**
     * <pre>
     * Digest of device provisioning, not logged.
     * </pre>
     *
     * <code>optional string digest = 3;</code>
     */
    private void setDigestBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
      digest_ = value.toStringUtf8();
    }

    public static final int LOCALE_FIELD_NUMBER = 6;
    private java.lang.String locale_;
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    public boolean hasLocale() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    public java.lang.String getLocale() {
      return locale_;
    }
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    public com.google.protobuf.ByteString
        getLocaleBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(locale_);
    }
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    private void setLocale(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
      locale_ = value;
    }
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    private void clearLocale() {
      bitField0_ = (bitField0_ & ~0x00000080);
      locale_ = getDefaultInstance().getLocale();
    }
    /**
     * <pre>
     * Current locale in standard (xx_XX) format
     * </pre>
     *
     * <code>optional string locale = 6;</code>
     */
    private void setLocaleBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
      locale_ = value.toStringUtf8();
    }

    public static final int CHECKIN_FIELD_NUMBER = 4;
    private checkin_proto.AndroidCheckin.AndroidCheckinProto checkin_;
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    public boolean hasCheckin() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    public checkin_proto.AndroidCheckin.AndroidCheckinProto getCheckin() {
      return checkin_ == null ? checkin_proto.AndroidCheckin.AndroidCheckinProto.getDefaultInstance() : checkin_;
    }
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    private void setCheckin(checkin_proto.AndroidCheckin.AndroidCheckinProto value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkin_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    private void setCheckin(
        checkin_proto.AndroidCheckin.AndroidCheckinProto.Builder builderForValue) {
      checkin_ = builderForValue.build();
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    private void mergeCheckin(checkin_proto.AndroidCheckin.AndroidCheckinProto value) {
      if (checkin_ != null &&
          checkin_ != checkin_proto.AndroidCheckin.AndroidCheckinProto.getDefaultInstance()) {
        checkin_ =
          checkin_proto.AndroidCheckin.AndroidCheckinProto.newBuilder(checkin_).mergeFrom(value).buildPartial();
      } else {
        checkin_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
     */
    private void clearCheckin() {  checkin_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int DESIRED_BUILD_FIELD_NUMBER = 5;
    private java.lang.String desiredBuild_;
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    public boolean hasDesiredBuild() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    public java.lang.String getDesiredBuild() {
      return desiredBuild_;
    }
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredBuildBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(desiredBuild_);
    }
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    private void setDesiredBuild(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000200;
      desiredBuild_ = value;
    }
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    private void clearDesiredBuild() {
      bitField0_ = (bitField0_ & ~0x00000200);
      desiredBuild_ = getDefaultInstance().getDesiredBuild();
    }
    /**
     * <pre>
     * DEPRECATED, see AndroidCheckinProto.requested_group
     * </pre>
     *
     * <code>optional string desired_build = 5;</code>
     */
    private void setDesiredBuildBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000200;
      desiredBuild_ = value.toStringUtf8();
    }

    public static final int MARKET_CHECKIN_FIELD_NUMBER = 8;
    private java.lang.String marketCheckin_;
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    public boolean hasMarketCheckin() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    public java.lang.String getMarketCheckin() {
      return marketCheckin_;
    }
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    public com.google.protobuf.ByteString
        getMarketCheckinBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(marketCheckin_);
    }
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    private void setMarketCheckin(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
      marketCheckin_ = value;
    }
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    private void clearMarketCheckin() {
      bitField0_ = (bitField0_ & ~0x00000400);
      marketCheckin_ = getDefaultInstance().getMarketCheckin();
    }
    /**
     * <pre>
     * Blob of data from the Market app to be passed to Market API server
     * </pre>
     *
     * <code>optional string market_checkin = 8;</code>
     */
    private void setMarketCheckinBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
      marketCheckin_ = value.toStringUtf8();
    }

    public static final int ACCOUNT_COOKIE_FIELD_NUMBER = 11;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> accountCookie_;
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    public java.util.List<java.lang.String> getAccountCookieList() {
      return accountCookie_;
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    public int getAccountCookieCount() {
      return accountCookie_.size();
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    public java.lang.String getAccountCookie(int index) {
      return accountCookie_.get(index);
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    public com.google.protobuf.ByteString
        getAccountCookieBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          accountCookie_.get(index));
    }
    private void ensureAccountCookieIsMutable() {
      if (!accountCookie_.isModifiable()) {
        accountCookie_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(accountCookie_);
       }
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    private void setAccountCookie(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAccountCookieIsMutable();
      accountCookie_.set(index, value);
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    private void addAccountCookie(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAccountCookieIsMutable();
      accountCookie_.add(value);
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    private void addAllAccountCookie(
        java.lang.Iterable<java.lang.String> values) {
      ensureAccountCookieIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, accountCookie_);
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    private void clearAccountCookie() {
      accountCookie_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * SID cookies of any google accounts stored on the phone.  Not logged.
     * </pre>
     *
     * <code>repeated string account_cookie = 11;</code>
     */
    private void addAccountCookieBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAccountCookieIsMutable();
      accountCookie_.add(value.toStringUtf8());
    }

    public static final int TIME_ZONE_FIELD_NUMBER = 12;
    private java.lang.String timeZone_;
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    public boolean hasTimeZone() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    public java.lang.String getTimeZone() {
      return timeZone_;
    }
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    public com.google.protobuf.ByteString
        getTimeZoneBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(timeZone_);
    }
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    private void setTimeZone(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
      timeZone_ = value;
    }
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    private void clearTimeZone() {
      bitField0_ = (bitField0_ & ~0x00000800);
      timeZone_ = getDefaultInstance().getTimeZone();
    }
    /**
     * <pre>
     * Time zone.  Not currently logged.
     * </pre>
     *
     * <code>optional string time_zone = 12;</code>
     */
    private void setTimeZoneBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
      timeZone_ = value.toStringUtf8();
    }

    public static final int SECURITY_TOKEN_FIELD_NUMBER = 13;
    private long securityToken_;
    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    public boolean hasSecurityToken() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    public long getSecurityToken() {
      return securityToken_;
    }
    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    private void setSecurityToken(long value) {
      bitField0_ |= 0x00001000;
      securityToken_ = value;
    }
    /**
     * <pre>
     * Security token used to validate the checkin request.
     * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
     * </pre>
     *
     * <code>optional fixed64 security_token = 13;</code>
     */
    private void clearSecurityToken() {
      bitField0_ = (bitField0_ & ~0x00001000);
      securityToken_ = 0L;
    }

    public static final int VERSION_FIELD_NUMBER = 14;
    private int version_;
    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    public boolean hasVersion() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    public int getVersion() {
      return version_;
    }
    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    private void setVersion(int value) {
      bitField0_ |= 0x00002000;
      version_ = value;
    }
    /**
     * <pre>
     * Version of checkin protocol.
     * There are currently two versions:
     * - version field missing: android IDs are assigned based on
     *   hardware identifiers.  unsecured in the sense that you can
     *   "unregister" someone's phone by sending a registration request
     *   with their IMEI/MEID/MAC.
     * - version=2: android IDs are assigned randomly.  The device is
     *   sent a security token that must be included in all future
     *   checkins for that android id.
     * - version=3: same as version 2, but the 'fragment' field is
     *   provided, and the device understands incremental updates to the
     *   gservices table (ie, only returning the keys whose values have
     *   changed.)
     * (version=1 was skipped to avoid confusion with the "missing"
     * version field that is effectively version 1.)
     * </pre>
     *
     * <code>optional int32 version = 14;</code>
     */
    private void clearVersion() {
      bitField0_ = (bitField0_ & ~0x00002000);
      version_ = 0;
    }

    public static final int OTA_CERT_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> otaCert_;
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    public java.util.List<java.lang.String> getOtaCertList() {
      return otaCert_;
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    public int getOtaCertCount() {
      return otaCert_.size();
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    public java.lang.String getOtaCert(int index) {
      return otaCert_.get(index);
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    public com.google.protobuf.ByteString
        getOtaCertBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          otaCert_.get(index));
    }
    private void ensureOtaCertIsMutable() {
      if (!otaCert_.isModifiable()) {
        otaCert_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(otaCert_);
       }
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    private void setOtaCert(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureOtaCertIsMutable();
      otaCert_.set(index, value);
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    private void addOtaCert(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureOtaCertIsMutable();
      otaCert_.add(value);
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    private void addAllOtaCert(
        java.lang.Iterable<java.lang.String> values) {
      ensureOtaCertIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, otaCert_);
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    private void clearOtaCert() {
      otaCert_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
     * logged.
     * </pre>
     *
     * <code>repeated string ota_cert = 15;</code>
     */
    private void addOtaCertBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureOtaCertIsMutable();
      otaCert_.add(value.toStringUtf8());
    }

    public static final int FRAGMENT_FIELD_NUMBER = 20;
    private int fragment_;
    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    public boolean hasFragment() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    public int getFragment() {
      return fragment_;
    }
    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    private void setFragment(int value) {
      bitField0_ |= 0x00004000;
      fragment_ = value;
    }
    /**
     * <pre>
     * A single CheckinTask on the device may lead to multiple checkin
     * requests if there is too much log data to upload in a single
     * request.  For version 3 and up, this field will be filled in with
     * the number of the request, starting with 0.
     * </pre>
     *
     * <code>optional int32 fragment = 20;</code>
     */
    private void clearFragment() {
      bitField0_ = (bitField0_ & ~0x00004000);
      fragment_ = 0;
    }

    public static final int USER_NAME_FIELD_NUMBER = 21;
    private java.lang.String userName_;
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    public boolean hasUserName() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    public java.lang.String getUserName() {
      return userName_;
    }
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    public com.google.protobuf.ByteString
        getUserNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(userName_);
    }
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    private void setUserName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
      userName_ = value;
    }
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    private void clearUserName() {
      bitField0_ = (bitField0_ & ~0x00008000);
      userName_ = getDefaultInstance().getUserName();
    }
    /**
     * <pre>
     * For devices supporting multiple users, the name of the current
     * profile (they all check in independently, just as if they were
     * multiple physical devices).  This may not be set, even if the
     * device is using multiuser.  (checkin.user_number should be set to
     * the ordinal of the user.)
     * </pre>
     *
     * <code>optional string user_name = 21;</code>
     */
    private void setUserNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
      userName_ = value.toStringUtf8();
    }

    public static final int USER_SERIAL_NUMBER_FIELD_NUMBER = 22;
    private int userSerialNumber_;
    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    public boolean hasUserSerialNumber() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    public int getUserSerialNumber() {
      return userSerialNumber_;
    }
    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    private void setUserSerialNumber(int value) {
      bitField0_ |= 0x00010000;
      userSerialNumber_ = value;
    }
    /**
     * <pre>
     * For devices supporting multiple user profiles, the serial number
     * for the user checking in.  Not logged.  May not be set, even if
     * the device supportes multiuser.  checkin.user_number is the
     * ordinal of the user (0, 1, 2, ...), which may be reused if users
     * are deleted and re-created.  user_serial_number is never reused
     * (unless the device is wiped).
     * </pre>
     *
     * <code>optional int32 user_serial_number = 22;</code>
     */
    private void clearUserSerialNumber() {
      bitField0_ = (bitField0_ & ~0x00010000);
      userSerialNumber_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getImei());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(2, id_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeString(3, getDigest());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(4, getCheckin());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeString(5, getDesiredBuild());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeString(6, getLocale());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt64(7, loggingId_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeString(8, getMarketCheckin());
      }
      for (int i = 0; i < macAddr_.size(); i++) {
        output.writeString(9, macAddr_.get(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeString(10, getMeid());
      }
      for (int i = 0; i < accountCookie_.size(); i++) {
        output.writeString(11, accountCookie_.get(i));
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeString(12, getTimeZone());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeFixed64(13, securityToken_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeInt32(14, version_);
      }
      for (int i = 0; i < otaCert_.size(); i++) {
        output.writeString(15, otaCert_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeString(16, getSerialNumber());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeString(17, getEsn());
      }
      for (int i = 0; i < macAddrType_.size(); i++) {
        output.writeString(19, macAddrType_.get(i));
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeInt32(20, fragment_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeString(21, getUserName());
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(22, userSerialNumber_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getImei());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, id_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(3, getDigest());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getCheckin());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(5, getDesiredBuild());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(6, getLocale());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, loggingId_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(8, getMarketCheckin());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < macAddr_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeStringSizeNoTag(macAddr_.get(i));
        }
        size += dataSize;
        size += 1 * getMacAddrList().size();
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(10, getMeid());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < accountCookie_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeStringSizeNoTag(accountCookie_.get(i));
        }
        size += dataSize;
        size += 1 * getAccountCookieList().size();
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(12, getTimeZone());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(13, securityToken_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(14, version_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < otaCert_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeStringSizeNoTag(otaCert_.get(i));
        }
        size += dataSize;
        size += 1 * getOtaCertList().size();
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(16, getSerialNumber());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(17, getEsn());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < macAddrType_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeStringSizeNoTag(macAddrType_.get(i));
        }
        size += dataSize;
        size += 2 * getMacAddrTypeList().size();
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, fragment_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(21, getUserName());
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(22, userSerialNumber_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(checkin_proto.Checkin.AndroidCheckinRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Devices send this every few hours to tell us how they're doing.
     * </pre>
     *
     * Protobuf type {@code checkin_proto.AndroidCheckinRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          checkin_proto.Checkin.AndroidCheckinRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:checkin_proto.AndroidCheckinRequest)
        checkin_proto.Checkin.AndroidCheckinRequestOrBuilder {
      // Construct using checkin_proto.Checkin.AndroidCheckinRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public boolean hasImei() {
        return instance.hasImei();
      }
      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public java.lang.String getImei() {
        return instance.getImei();
      }
      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public com.google.protobuf.ByteString
          getImeiBytes() {
        return instance.getImeiBytes();
      }
      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public Builder setImei(
          java.lang.String value) {
        copyOnWrite();
        instance.setImei(value);
        return this;
      }
      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public Builder clearImei() {
        copyOnWrite();
        instance.clearImei();
        return this;
      }
      /**
       * <pre>
       * IMEI (used by GSM phones) is sent and stored as 15 decimal
       * digits; the 15th is a check digit.
       * </pre>
       *
       * <code>optional string imei = 1;</code>
       */
      public Builder setImeiBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setImeiBytes(value);
        return this;
      }

      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public boolean hasMeid() {
        return instance.hasMeid();
      }
      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public java.lang.String getMeid() {
        return instance.getMeid();
      }
      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public com.google.protobuf.ByteString
          getMeidBytes() {
        return instance.getMeidBytes();
      }
      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public Builder setMeid(
          java.lang.String value) {
        copyOnWrite();
        instance.setMeid(value);
        return this;
      }
      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public Builder clearMeid() {
        copyOnWrite();
        instance.clearMeid();
        return this;
      }
      /**
       * <pre>
       * MEID (used by CDMA phones) is sent and stored as 14 hexadecimal
       * digits (no check digit).
       * </pre>
       *
       * <code>optional string meid = 10;</code>
       */
      public Builder setMeidBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMeidBytes(value);
        return this;
      }

      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public java.util.List<java.lang.String>
          getMacAddrList() {
        return java.util.Collections.unmodifiableList(
            instance.getMacAddrList());
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public int getMacAddrCount() {
        return instance.getMacAddrCount();
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public java.lang.String getMacAddr(int index) {
        return instance.getMacAddr(index);
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public com.google.protobuf.ByteString
          getMacAddrBytes(int index) {
        return instance.getMacAddrBytes(index);
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public Builder setMacAddr(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setMacAddr(index, value);
        return this;
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public Builder addMacAddr(
          java.lang.String value) {
        copyOnWrite();
        instance.addMacAddr(value);
        return this;
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public Builder addAllMacAddr(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllMacAddr(values);
        return this;
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public Builder clearMacAddr() {
        copyOnWrite();
        instance.clearMacAddr();
        return this;
      }
      /**
       * <pre>
       * MAC address (used by non-phone devices).  12 hexadecimal digits;
       * no separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
       * </pre>
       *
       * <code>repeated string mac_addr = 9;</code>
       */
      public Builder addMacAddrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addMacAddrBytes(value);
        return this;
      }

      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public java.util.List<java.lang.String>
          getMacAddrTypeList() {
        return java.util.Collections.unmodifiableList(
            instance.getMacAddrTypeList());
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public int getMacAddrTypeCount() {
        return instance.getMacAddrTypeCount();
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public java.lang.String getMacAddrType(int index) {
        return instance.getMacAddrType(index);
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public com.google.protobuf.ByteString
          getMacAddrTypeBytes(int index) {
        return instance.getMacAddrTypeBytes(index);
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public Builder setMacAddrType(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setMacAddrType(index, value);
        return this;
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public Builder addMacAddrType(
          java.lang.String value) {
        copyOnWrite();
        instance.addMacAddrType(value);
        return this;
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public Builder addAllMacAddrType(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllMacAddrType(values);
        return this;
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public Builder clearMacAddrType() {
        copyOnWrite();
        instance.clearMacAddrType();
        return this;
      }
      /**
       * <pre>
       * An array parallel to mac_addr, describing the type of interface.
       * Currently accepted values: "wifi", "ethernet", "bluetooth".  If
       * not present, "wifi" is assumed.
       * </pre>
       *
       * <code>repeated string mac_addr_type = 19;</code>
       */
      public Builder addMacAddrTypeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addMacAddrTypeBytes(value);
        return this;
      }

      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public boolean hasSerialNumber() {
        return instance.hasSerialNumber();
      }
      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public java.lang.String getSerialNumber() {
        return instance.getSerialNumber();
      }
      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public com.google.protobuf.ByteString
          getSerialNumberBytes() {
        return instance.getSerialNumberBytes();
      }
      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public Builder setSerialNumber(
          java.lang.String value) {
        copyOnWrite();
        instance.setSerialNumber(value);
        return this;
      }
      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public Builder clearSerialNumber() {
        copyOnWrite();
        instance.clearSerialNumber();
        return this;
      }
      /**
       * <pre>
       * Serial number (a manufacturer-defined unique hardware
       * identifier).  Alphanumeric, case-insensitive.
       * </pre>
       *
       * <code>optional string serial_number = 16;</code>
       */
      public Builder setSerialNumberBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSerialNumberBytes(value);
        return this;
      }

      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public boolean hasEsn() {
        return instance.hasEsn();
      }
      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public java.lang.String getEsn() {
        return instance.getEsn();
      }
      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public com.google.protobuf.ByteString
          getEsnBytes() {
        return instance.getEsnBytes();
      }
      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public Builder setEsn(
          java.lang.String value) {
        copyOnWrite();
        instance.setEsn(value);
        return this;
      }
      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public Builder clearEsn() {
        copyOnWrite();
        instance.clearEsn();
        return this;
      }
      /**
       * <pre>
       * Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
       * </pre>
       *
       * <code>optional string esn = 17;</code>
       */
      public Builder setEsnBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setEsnBytes(value);
        return this;
      }

      /**
       * <pre>
       * Android device ID, not logged
       * </pre>
       *
       * <code>optional int64 id = 2;</code>
       */
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * Android device ID, not logged
       * </pre>
       *
       * <code>optional int64 id = 2;</code>
       */
      public long getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Android device ID, not logged
       * </pre>
       *
       * <code>optional int64 id = 2;</code>
       */
      public Builder setId(long value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Android device ID, not logged
       * </pre>
       *
       * <code>optional int64 id = 2;</code>
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }

      /**
       * <pre>
       * Pseudonymous logging ID for Sawmill
       * </pre>
       *
       * <code>optional int64 logging_id = 7;</code>
       */
      public boolean hasLoggingId() {
        return instance.hasLoggingId();
      }
      /**
       * <pre>
       * Pseudonymous logging ID for Sawmill
       * </pre>
       *
       * <code>optional int64 logging_id = 7;</code>
       */
      public long getLoggingId() {
        return instance.getLoggingId();
      }
      /**
       * <pre>
       * Pseudonymous logging ID for Sawmill
       * </pre>
       *
       * <code>optional int64 logging_id = 7;</code>
       */
      public Builder setLoggingId(long value) {
        copyOnWrite();
        instance.setLoggingId(value);
        return this;
      }
      /**
       * <pre>
       * Pseudonymous logging ID for Sawmill
       * </pre>
       *
       * <code>optional int64 logging_id = 7;</code>
       */
      public Builder clearLoggingId() {
        copyOnWrite();
        instance.clearLoggingId();
        return this;
      }

      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public boolean hasDigest() {
        return instance.hasDigest();
      }
      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public java.lang.String getDigest() {
        return instance.getDigest();
      }
      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public com.google.protobuf.ByteString
          getDigestBytes() {
        return instance.getDigestBytes();
      }
      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public Builder setDigest(
          java.lang.String value) {
        copyOnWrite();
        instance.setDigest(value);
        return this;
      }
      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public Builder clearDigest() {
        copyOnWrite();
        instance.clearDigest();
        return this;
      }
      /**
       * <pre>
       * Digest of device provisioning, not logged.
       * </pre>
       *
       * <code>optional string digest = 3;</code>
       */
      public Builder setDigestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDigestBytes(value);
        return this;
      }

      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public boolean hasLocale() {
        return instance.hasLocale();
      }
      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public java.lang.String getLocale() {
        return instance.getLocale();
      }
      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public com.google.protobuf.ByteString
          getLocaleBytes() {
        return instance.getLocaleBytes();
      }
      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public Builder setLocale(
          java.lang.String value) {
        copyOnWrite();
        instance.setLocale(value);
        return this;
      }
      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public Builder clearLocale() {
        copyOnWrite();
        instance.clearLocale();
        return this;
      }
      /**
       * <pre>
       * Current locale in standard (xx_XX) format
       * </pre>
       *
       * <code>optional string locale = 6;</code>
       */
      public Builder setLocaleBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLocaleBytes(value);
        return this;
      }

      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public boolean hasCheckin() {
        return instance.hasCheckin();
      }
      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public checkin_proto.AndroidCheckin.AndroidCheckinProto getCheckin() {
        return instance.getCheckin();
      }
      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public Builder setCheckin(checkin_proto.AndroidCheckin.AndroidCheckinProto value) {
        copyOnWrite();
        instance.setCheckin(value);
        return this;
        }
      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public Builder setCheckin(
          checkin_proto.AndroidCheckin.AndroidCheckinProto.Builder builderForValue) {
        copyOnWrite();
        instance.setCheckin(builderForValue);
        return this;
      }
      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public Builder mergeCheckin(checkin_proto.AndroidCheckin.AndroidCheckinProto value) {
        copyOnWrite();
        instance.mergeCheckin(value);
        return this;
      }
      /**
       * <code>required .checkin_proto.AndroidCheckinProto checkin = 4;</code>
       */
      public Builder clearCheckin() {  copyOnWrite();
        instance.clearCheckin();
        return this;
      }

      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public boolean hasDesiredBuild() {
        return instance.hasDesiredBuild();
      }
      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public java.lang.String getDesiredBuild() {
        return instance.getDesiredBuild();
      }
      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public com.google.protobuf.ByteString
          getDesiredBuildBytes() {
        return instance.getDesiredBuildBytes();
      }
      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public Builder setDesiredBuild(
          java.lang.String value) {
        copyOnWrite();
        instance.setDesiredBuild(value);
        return this;
      }
      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public Builder clearDesiredBuild() {
        copyOnWrite();
        instance.clearDesiredBuild();
        return this;
      }
      /**
       * <pre>
       * DEPRECATED, see AndroidCheckinProto.requested_group
       * </pre>
       *
       * <code>optional string desired_build = 5;</code>
       */
      public Builder setDesiredBuildBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDesiredBuildBytes(value);
        return this;
      }

      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public boolean hasMarketCheckin() {
        return instance.hasMarketCheckin();
      }
      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public java.lang.String getMarketCheckin() {
        return instance.getMarketCheckin();
      }
      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public com.google.protobuf.ByteString
          getMarketCheckinBytes() {
        return instance.getMarketCheckinBytes();
      }
      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public Builder setMarketCheckin(
          java.lang.String value) {
        copyOnWrite();
        instance.setMarketCheckin(value);
        return this;
      }
      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public Builder clearMarketCheckin() {
        copyOnWrite();
        instance.clearMarketCheckin();
        return this;
      }
      /**
       * <pre>
       * Blob of data from the Market app to be passed to Market API server
       * </pre>
       *
       * <code>optional string market_checkin = 8;</code>
       */
      public Builder setMarketCheckinBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMarketCheckinBytes(value);
        return this;
      }

      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public java.util.List<java.lang.String>
          getAccountCookieList() {
        return java.util.Collections.unmodifiableList(
            instance.getAccountCookieList());
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public int getAccountCookieCount() {
        return instance.getAccountCookieCount();
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public java.lang.String getAccountCookie(int index) {
        return instance.getAccountCookie(index);
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public com.google.protobuf.ByteString
          getAccountCookieBytes(int index) {
        return instance.getAccountCookieBytes(index);
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public Builder setAccountCookie(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setAccountCookie(index, value);
        return this;
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public Builder addAccountCookie(
          java.lang.String value) {
        copyOnWrite();
        instance.addAccountCookie(value);
        return this;
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public Builder addAllAccountCookie(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllAccountCookie(values);
        return this;
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public Builder clearAccountCookie() {
        copyOnWrite();
        instance.clearAccountCookie();
        return this;
      }
      /**
       * <pre>
       * SID cookies of any google accounts stored on the phone.  Not logged.
       * </pre>
       *
       * <code>repeated string account_cookie = 11;</code>
       */
      public Builder addAccountCookieBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addAccountCookieBytes(value);
        return this;
      }

      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public boolean hasTimeZone() {
        return instance.hasTimeZone();
      }
      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public java.lang.String getTimeZone() {
        return instance.getTimeZone();
      }
      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public com.google.protobuf.ByteString
          getTimeZoneBytes() {
        return instance.getTimeZoneBytes();
      }
      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public Builder setTimeZone(
          java.lang.String value) {
        copyOnWrite();
        instance.setTimeZone(value);
        return this;
      }
      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public Builder clearTimeZone() {
        copyOnWrite();
        instance.clearTimeZone();
        return this;
      }
      /**
       * <pre>
       * Time zone.  Not currently logged.
       * </pre>
       *
       * <code>optional string time_zone = 12;</code>
       */
      public Builder setTimeZoneBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTimeZoneBytes(value);
        return this;
      }

      /**
       * <pre>
       * Security token used to validate the checkin request.
       * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
       * </pre>
       *
       * <code>optional fixed64 security_token = 13;</code>
       */
      public boolean hasSecurityToken() {
        return instance.hasSecurityToken();
      }
      /**
       * <pre>
       * Security token used to validate the checkin request.
       * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
       * </pre>
       *
       * <code>optional fixed64 security_token = 13;</code>
       */
      public long getSecurityToken() {
        return instance.getSecurityToken();
      }
      /**
       * <pre>
       * Security token used to validate the checkin request.
       * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
       * </pre>
       *
       * <code>optional fixed64 security_token = 13;</code>
       */
      public Builder setSecurityToken(long value) {
        copyOnWrite();
        instance.setSecurityToken(value);
        return this;
      }
      /**
       * <pre>
       * Security token used to validate the checkin request.
       * Required for android IDs issued to Froyo+ devices, not for legacy IDs.
       * </pre>
       *
       * <code>optional fixed64 security_token = 13;</code>
       */
      public Builder clearSecurityToken() {
        copyOnWrite();
        instance.clearSecurityToken();
        return this;
      }

      /**
       * <pre>
       * Version of checkin protocol.
       * There are currently two versions:
       * - version field missing: android IDs are assigned based on
       *   hardware identifiers.  unsecured in the sense that you can
       *   "unregister" someone's phone by sending a registration request
       *   with their IMEI/MEID/MAC.
       * - version=2: android IDs are assigned randomly.  The device is
       *   sent a security token that must be included in all future
       *   checkins for that android id.
       * - version=3: same as version 2, but the 'fragment' field is
       *   provided, and the device understands incremental updates to the
       *   gservices table (ie, only returning the keys whose values have
       *   changed.)
       * (version=1 was skipped to avoid confusion with the "missing"
       * version field that is effectively version 1.)
       * </pre>
       *
       * <code>optional int32 version = 14;</code>
       */
      public boolean hasVersion() {
        return instance.hasVersion();
      }
      /**
       * <pre>
       * Version of checkin protocol.
       * There are currently two versions:
       * - version field missing: android IDs are assigned based on
       *   hardware identifiers.  unsecured in the sense that you can
       *   "unregister" someone's phone by sending a registration request
       *   with their IMEI/MEID/MAC.
       * - version=2: android IDs are assigned randomly.  The device is
       *   sent a security token that must be included in all future
       *   checkins for that android id.
       * - version=3: same as version 2, but the 'fragment' field is
       *   provided, and the device understands incremental updates to the
       *   gservices table (ie, only returning the keys whose values have
       *   changed.)
       * (version=1 was skipped to avoid confusion with the "missing"
       * version field that is effectively version 1.)
       * </pre>
       *
       * <code>optional int32 version = 14;</code>
       */
      public int getVersion() {
        return instance.getVersion();
      }
      /**
       * <pre>
       * Version of checkin protocol.
       * There are currently two versions:
       * - version field missing: android IDs are assigned based on
       *   hardware identifiers.  unsecured in the sense that you can
       *   "unregister" someone's phone by sending a registration request
       *   with their IMEI/MEID/MAC.
       * - version=2: android IDs are assigned randomly.  The device is
       *   sent a security token that must be included in all future
       *   checkins for that android id.
       * - version=3: same as version 2, but the 'fragment' field is
       *   provided, and the device understands incremental updates to the
       *   gservices table (ie, only returning the keys whose values have
       *   changed.)
       * (version=1 was skipped to avoid confusion with the "missing"
       * version field that is effectively version 1.)
       * </pre>
       *
       * <code>optional int32 version = 14;</code>
       */
      public Builder setVersion(int value) {
        copyOnWrite();
        instance.setVersion(value);
        return this;
      }
      /**
       * <pre>
       * Version of checkin protocol.
       * There are currently two versions:
       * - version field missing: android IDs are assigned based on
       *   hardware identifiers.  unsecured in the sense that you can
       *   "unregister" someone's phone by sending a registration request
       *   with their IMEI/MEID/MAC.
       * - version=2: android IDs are assigned randomly.  The device is
       *   sent a security token that must be included in all future
       *   checkins for that android id.
       * - version=3: same as version 2, but the 'fragment' field is
       *   provided, and the device understands incremental updates to the
       *   gservices table (ie, only returning the keys whose values have
       *   changed.)
       * (version=1 was skipped to avoid confusion with the "missing"
       * version field that is effectively version 1.)
       * </pre>
       *
       * <code>optional int32 version = 14;</code>
       */
      public Builder clearVersion() {
        copyOnWrite();
        instance.clearVersion();
        return this;
      }

      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public java.util.List<java.lang.String>
          getOtaCertList() {
        return java.util.Collections.unmodifiableList(
            instance.getOtaCertList());
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public int getOtaCertCount() {
        return instance.getOtaCertCount();
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public java.lang.String getOtaCert(int index) {
        return instance.getOtaCert(index);
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public com.google.protobuf.ByteString
          getOtaCertBytes(int index) {
        return instance.getOtaCertBytes(index);
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public Builder setOtaCert(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setOtaCert(index, value);
        return this;
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public Builder addOtaCert(
          java.lang.String value) {
        copyOnWrite();
        instance.addOtaCert(value);
        return this;
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public Builder addAllOtaCert(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllOtaCert(values);
        return this;
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public Builder clearOtaCert() {
        copyOnWrite();
        instance.clearOtaCert();
        return this;
      }
      /**
       * <pre>
       * OTA certs accepted by device (base-64 SHA-1 of cert files).  Not
       * logged.
       * </pre>
       *
       * <code>repeated string ota_cert = 15;</code>
       */
      public Builder addOtaCertBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addOtaCertBytes(value);
        return this;
      }

      /**
       * <pre>
       * A single CheckinTask on the device may lead to multiple checkin
       * requests if there is too much log data to upload in a single
       * request.  For version 3 and up, this field will be filled in with
       * the number of the request, starting with 0.
       * </pre>
       *
       * <code>optional int32 fragment = 20;</code>
       */
      public boolean hasFragment() {
        return instance.hasFragment();
      }
      /**
       * <pre>
       * A single CheckinTask on the device may lead to multiple checkin
       * requests if there is too much log data to upload in a single
       * request.  For version 3 and up, this field will be filled in with
       * the number of the request, starting with 0.
       * </pre>
       *
       * <code>optional int32 fragment = 20;</code>
       */
      public int getFragment() {
        return instance.getFragment();
      }
      /**
       * <pre>
       * A single CheckinTask on the device may lead to multiple checkin
       * requests if there is too much log data to upload in a single
       * request.  For version 3 and up, this field will be filled in with
       * the number of the request, starting with 0.
       * </pre>
       *
       * <code>optional int32 fragment = 20;</code>
       */
      public Builder setFragment(int value) {
        copyOnWrite();
        instance.setFragment(value);
        return this;
      }
      /**
       * <pre>
       * A single CheckinTask on the device may lead to multiple checkin
       * requests if there is too much log data to upload in a single
       * request.  For version 3 and up, this field will be filled in with
       * the number of the request, starting with 0.
       * </pre>
       *
       * <code>optional int32 fragment = 20;</code>
       */
      public Builder clearFragment() {
        copyOnWrite();
        instance.clearFragment();
        return this;
      }

      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public boolean hasUserName() {
        return instance.hasUserName();
      }
      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public java.lang.String getUserName() {
        return instance.getUserName();
      }
      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public com.google.protobuf.ByteString
          getUserNameBytes() {
        return instance.getUserNameBytes();
      }
      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public Builder setUserName(
          java.lang.String value) {
        copyOnWrite();
        instance.setUserName(value);
        return this;
      }
      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public Builder clearUserName() {
        copyOnWrite();
        instance.clearUserName();
        return this;
      }
      /**
       * <pre>
       * For devices supporting multiple users, the name of the current
       * profile (they all check in independently, just as if they were
       * multiple physical devices).  This may not be set, even if the
       * device is using multiuser.  (checkin.user_number should be set to
       * the ordinal of the user.)
       * </pre>
       *
       * <code>optional string user_name = 21;</code>
       */
      public Builder setUserNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUserNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * For devices supporting multiple user profiles, the serial number
       * for the user checking in.  Not logged.  May not be set, even if
       * the device supportes multiuser.  checkin.user_number is the
       * ordinal of the user (0, 1, 2, ...), which may be reused if users
       * are deleted and re-created.  user_serial_number is never reused
       * (unless the device is wiped).
       * </pre>
       *
       * <code>optional int32 user_serial_number = 22;</code>
       */
      public boolean hasUserSerialNumber() {
        return instance.hasUserSerialNumber();
      }
      /**
       * <pre>
       * For devices supporting multiple user profiles, the serial number
       * for the user checking in.  Not logged.  May not be set, even if
       * the device supportes multiuser.  checkin.user_number is the
       * ordinal of the user (0, 1, 2, ...), which may be reused if users
       * are deleted and re-created.  user_serial_number is never reused
       * (unless the device is wiped).
       * </pre>
       *
       * <code>optional int32 user_serial_number = 22;</code>
       */
      public int getUserSerialNumber() {
        return instance.getUserSerialNumber();
      }
      /**
       * <pre>
       * For devices supporting multiple user profiles, the serial number
       * for the user checking in.  Not logged.  May not be set, even if
       * the device supportes multiuser.  checkin.user_number is the
       * ordinal of the user (0, 1, 2, ...), which may be reused if users
       * are deleted and re-created.  user_serial_number is never reused
       * (unless the device is wiped).
       * </pre>
       *
       * <code>optional int32 user_serial_number = 22;</code>
       */
      public Builder setUserSerialNumber(int value) {
        copyOnWrite();
        instance.setUserSerialNumber(value);
        return this;
      }
      /**
       * <pre>
       * For devices supporting multiple user profiles, the serial number
       * for the user checking in.  Not logged.  May not be set, even if
       * the device supportes multiuser.  checkin.user_number is the
       * ordinal of the user (0, 1, 2, ...), which may be reused if users
       * are deleted and re-created.  user_serial_number is never reused
       * (unless the device is wiped).
       * </pre>
       *
       * <code>optional int32 user_serial_number = 22;</code>
       */
      public Builder clearUserSerialNumber() {
        copyOnWrite();
        instance.clearUserSerialNumber();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:checkin_proto.AndroidCheckinRequest)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new checkin_proto.Checkin.AndroidCheckinRequest();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasCheckin()) {
            return null;
          }
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          macAddr_.makeImmutable();
          macAddrType_.makeImmutable();
          accountCookie_.makeImmutable();
          otaCert_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          checkin_proto.Checkin.AndroidCheckinRequest other = (checkin_proto.Checkin.AndroidCheckinRequest) arg1;
          imei_ = visitor.visitString(
              hasImei(), imei_,
              other.hasImei(), other.imei_);
          meid_ = visitor.visitString(
              hasMeid(), meid_,
              other.hasMeid(), other.meid_);
          macAddr_= visitor.visitList(macAddr_, other.macAddr_);
          macAddrType_= visitor.visitList(macAddrType_, other.macAddrType_);
          serialNumber_ = visitor.visitString(
              hasSerialNumber(), serialNumber_,
              other.hasSerialNumber(), other.serialNumber_);
          esn_ = visitor.visitString(
              hasEsn(), esn_,
              other.hasEsn(), other.esn_);
          id_ = visitor.visitLong(
              hasId(), id_,
              other.hasId(), other.id_);
          loggingId_ = visitor.visitLong(
              hasLoggingId(), loggingId_,
              other.hasLoggingId(), other.loggingId_);
          digest_ = visitor.visitString(
              hasDigest(), digest_,
              other.hasDigest(), other.digest_);
          locale_ = visitor.visitString(
              hasLocale(), locale_,
              other.hasLocale(), other.locale_);
          checkin_ = visitor.visitMessage(checkin_, other.checkin_);
          desiredBuild_ = visitor.visitString(
              hasDesiredBuild(), desiredBuild_,
              other.hasDesiredBuild(), other.desiredBuild_);
          marketCheckin_ = visitor.visitString(
              hasMarketCheckin(), marketCheckin_,
              other.hasMarketCheckin(), other.marketCheckin_);
          accountCookie_= visitor.visitList(accountCookie_, other.accountCookie_);
          timeZone_ = visitor.visitString(
              hasTimeZone(), timeZone_,
              other.hasTimeZone(), other.timeZone_);
          securityToken_ = visitor.visitLong(
              hasSecurityToken(), securityToken_,
              other.hasSecurityToken(), other.securityToken_);
          version_ = visitor.visitInt(
              hasVersion(), version_,
              other.hasVersion(), other.version_);
          otaCert_= visitor.visitList(otaCert_, other.otaCert_);
          fragment_ = visitor.visitInt(
              hasFragment(), fragment_,
              other.hasFragment(), other.fragment_);
          userName_ = visitor.visitString(
              hasUserName(), userName_,
              other.hasUserName(), other.userName_);
          userSerialNumber_ = visitor.visitInt(
              hasUserSerialNumber(), userSerialNumber_,
              other.hasUserSerialNumber(), other.userSerialNumber_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000001;
                  imei_ = s;
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000010;
                  id_ = input.readInt64();
                  break;
                }
                case 26: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000040;
                  digest_ = s;
                  break;
                }
                case 34: {
                  checkin_proto.AndroidCheckin.AndroidCheckinProto.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000100) == 0x00000100)) {
                    subBuilder = checkin_.toBuilder();
                  }
                  checkin_ = input.readMessage(checkin_proto.AndroidCheckin.AndroidCheckinProto.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(checkin_);
                    checkin_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000100;
                  break;
                }
                case 42: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000200;
                  desiredBuild_ = s;
                  break;
                }
                case 50: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000080;
                  locale_ = s;
                  break;
                }
                case 56: {
                  bitField0_ |= 0x00000020;
                  loggingId_ = input.readInt64();
                  break;
                }
                case 66: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000400;
                  marketCheckin_ = s;
                  break;
                }
                case 74: {
                  java.lang.String s = input.readString();
                  if (!macAddr_.isModifiable()) {
                    macAddr_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(macAddr_);
                  }
                  macAddr_.add(s);
                  break;
                }
                case 82: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000002;
                  meid_ = s;
                  break;
                }
                case 90: {
                  java.lang.String s = input.readString();
                  if (!accountCookie_.isModifiable()) {
                    accountCookie_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(accountCookie_);
                  }
                  accountCookie_.add(s);
                  break;
                }
                case 98: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000800;
                  timeZone_ = s;
                  break;
                }
                case 105: {
                  bitField0_ |= 0x00001000;
                  securityToken_ = input.readFixed64();
                  break;
                }
                case 112: {
                  bitField0_ |= 0x00002000;
                  version_ = input.readInt32();
                  break;
                }
                case 122: {
                  java.lang.String s = input.readString();
                  if (!otaCert_.isModifiable()) {
                    otaCert_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(otaCert_);
                  }
                  otaCert_.add(s);
                  break;
                }
                case 130: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000004;
                  serialNumber_ = s;
                  break;
                }
                case 138: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000008;
                  esn_ = s;
                  break;
                }
                case 154: {
                  java.lang.String s = input.readString();
                  if (!macAddrType_.isModifiable()) {
                    macAddrType_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(macAddrType_);
                  }
                  macAddrType_.add(s);
                  break;
                }
                case 160: {
                  bitField0_ |= 0x00004000;
                  fragment_ = input.readInt32();
                  break;
                }
                case 170: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00008000;
                  userName_ = s;
                  break;
                }
                case 176: {
                  bitField0_ |= 0x00010000;
                  userSerialNumber_ = input.readInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (checkin_proto.Checkin.AndroidCheckinRequest.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:checkin_proto.AndroidCheckinRequest)
    private static final checkin_proto.Checkin.AndroidCheckinRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new AndroidCheckinRequest();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static checkin_proto.Checkin.AndroidCheckinRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AndroidCheckinRequest> PARSER;

    public static com.google.protobuf.Parser<AndroidCheckinRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AndroidCheckinResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:checkin_proto.AndroidCheckinResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    boolean hasStatsOk();
    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    boolean getStatsOk();

    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    boolean hasTimeMsec();
    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    long getTimeMsec();

    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    boolean hasDigest();
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    java.lang.String getDigest();
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    com.google.protobuf.ByteString
        getDigestBytes();

    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    boolean hasSettingsDiff();
    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    boolean getSettingsDiff();

    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    java.util.List<java.lang.String>
        getDeleteSettingList();
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    int getDeleteSettingCount();
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    java.lang.String getDeleteSetting(int index);
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    com.google.protobuf.ByteString
        getDeleteSettingBytes(int index);

    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    java.util.List<checkin_proto.Checkin.GservicesSetting> 
        getSettingList();
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    checkin_proto.Checkin.GservicesSetting getSetting(int index);
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    int getSettingCount();

    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    boolean hasMarketOk();
    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    boolean getMarketOk();

    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    boolean hasAndroidId();
    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    long getAndroidId();

    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    boolean hasSecurityToken();
    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    long getSecurityToken();

    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    boolean hasVersionInfo();
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    java.lang.String getVersionInfo();
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    com.google.protobuf.ByteString
        getVersionInfoBytes();
  }
  /**
   * <pre>
   * The response to the device.
   * </pre>
   *
   * Protobuf type {@code checkin_proto.AndroidCheckinResponse}
   */
  public  static final class AndroidCheckinResponse extends
      com.google.protobuf.GeneratedMessageLite<
          AndroidCheckinResponse, AndroidCheckinResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:checkin_proto.AndroidCheckinResponse)
      AndroidCheckinResponseOrBuilder {
    private AndroidCheckinResponse() {
      digest_ = "";
      deleteSetting_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      setting_ = emptyProtobufList();
      versionInfo_ = "";
    }
    private int bitField0_;
    public static final int STATS_OK_FIELD_NUMBER = 1;
    private boolean statsOk_;
    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    public boolean hasStatsOk() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    public boolean getStatsOk() {
      return statsOk_;
    }
    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    private void setStatsOk(boolean value) {
      bitField0_ |= 0x00000001;
      statsOk_ = value;
    }
    /**
     * <pre>
     * Whether statistics were recorded properly.
     * </pre>
     *
     * <code>required bool stats_ok = 1;</code>
     */
    private void clearStatsOk() {
      bitField0_ = (bitField0_ & ~0x00000001);
      statsOk_ = false;
    }

    public static final int TIME_MSEC_FIELD_NUMBER = 3;
    private long timeMsec_;
    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    public boolean hasTimeMsec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    public long getTimeMsec() {
      return timeMsec_;
    }
    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    private void setTimeMsec(long value) {
      bitField0_ |= 0x00000002;
      timeMsec_ = value;
    }
    /**
     * <pre>
     * Time of day from server (Java epoch).
     * </pre>
     *
     * <code>optional int64 time_msec = 3;</code>
     */
    private void clearTimeMsec() {
      bitField0_ = (bitField0_ & ~0x00000002);
      timeMsec_ = 0L;
    }

    public static final int DIGEST_FIELD_NUMBER = 4;
    private java.lang.String digest_;
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    public boolean hasDigest() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    public java.lang.String getDigest() {
      return digest_;
    }
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    public com.google.protobuf.ByteString
        getDigestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(digest_);
    }
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    private void setDigest(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      digest_ = value;
    }
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    private void clearDigest() {
      bitField0_ = (bitField0_ & ~0x00000004);
      digest_ = getDefaultInstance().getDigest();
    }
    /**
     * <pre>
     * Provisioning is sent if the request included an obsolete digest.
     * For version &lt;= 2, 'digest' contains the digest that should be
     * sent back to the server on the next checkin, and 'setting'
     * contains the entire gservices table (which replaces the entire
     * current table on the device).
     * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
     * is false, then 'setting' contains the entire table, as in version
     * 2.  If 'settings_diff' is true, then 'delete_setting' contains
     * the keys to delete, and 'setting' contains only keys to be added
     * or for which the value has changed.  All other keys in the
     * current table should be left untouched.  If 'settings_diff' is
     * absent, don't touch the existing gservices table.
     * </pre>
     *
     * <code>optional string digest = 4;</code>
     */
    private void setDigestBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      digest_ = value.toStringUtf8();
    }

    public static final int SETTINGS_DIFF_FIELD_NUMBER = 9;
    private boolean settingsDiff_;
    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    public boolean hasSettingsDiff() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    public boolean getSettingsDiff() {
      return settingsDiff_;
    }
    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    private void setSettingsDiff(boolean value) {
      bitField0_ |= 0x00000008;
      settingsDiff_ = value;
    }
    /**
     * <code>optional bool settings_diff = 9;</code>
     */
    private void clearSettingsDiff() {
      bitField0_ = (bitField0_ & ~0x00000008);
      settingsDiff_ = false;
    }

    public static final int DELETE_SETTING_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> deleteSetting_;
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    public java.util.List<java.lang.String> getDeleteSettingList() {
      return deleteSetting_;
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    public int getDeleteSettingCount() {
      return deleteSetting_.size();
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    public java.lang.String getDeleteSetting(int index) {
      return deleteSetting_.get(index);
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    public com.google.protobuf.ByteString
        getDeleteSettingBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          deleteSetting_.get(index));
    }
    private void ensureDeleteSettingIsMutable() {
      if (!deleteSetting_.isModifiable()) {
        deleteSetting_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(deleteSetting_);
       }
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    private void setDeleteSetting(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureDeleteSettingIsMutable();
      deleteSetting_.set(index, value);
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    private void addDeleteSetting(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureDeleteSettingIsMutable();
      deleteSetting_.add(value);
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    private void addAllDeleteSetting(
        java.lang.Iterable<java.lang.String> values) {
      ensureDeleteSettingIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, deleteSetting_);
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    private void clearDeleteSetting() {
      deleteSetting_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <code>repeated string delete_setting = 10;</code>
     */
    private void addDeleteSettingBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureDeleteSettingIsMutable();
      deleteSetting_.add(value.toStringUtf8());
    }

    public static final int SETTING_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<checkin_proto.Checkin.GservicesSetting> setting_;
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    public java.util.List<checkin_proto.Checkin.GservicesSetting> getSettingList() {
      return setting_;
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    public java.util.List<? extends checkin_proto.Checkin.GservicesSettingOrBuilder> 
        getSettingOrBuilderList() {
      return setting_;
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    public int getSettingCount() {
      return setting_.size();
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    public checkin_proto.Checkin.GservicesSetting getSetting(int index) {
      return setting_.get(index);
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    public checkin_proto.Checkin.GservicesSettingOrBuilder getSettingOrBuilder(
        int index) {
      return setting_.get(index);
    }
    private void ensureSettingIsMutable() {
      if (!setting_.isModifiable()) {
        setting_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(setting_);
       }
    }

    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void setSetting(
        int index, checkin_proto.Checkin.GservicesSetting value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSettingIsMutable();
      setting_.set(index, value);
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void setSetting(
        int index, checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
      ensureSettingIsMutable();
      setting_.set(index, builderForValue.build());
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void addSetting(checkin_proto.Checkin.GservicesSetting value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSettingIsMutable();
      setting_.add(value);
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void addSetting(
        int index, checkin_proto.Checkin.GservicesSetting value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSettingIsMutable();
      setting_.add(index, value);
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void addSetting(
        checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
      ensureSettingIsMutable();
      setting_.add(builderForValue.build());
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void addSetting(
        int index, checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
      ensureSettingIsMutable();
      setting_.add(index, builderForValue.build());
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void addAllSetting(
        java.lang.Iterable<? extends checkin_proto.Checkin.GservicesSetting> values) {
      ensureSettingIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, setting_);
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void clearSetting() {
      setting_ = emptyProtobufList();
    }
    /**
     * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
     */
    private void removeSetting(int index) {
      ensureSettingIsMutable();
      setting_.remove(index);
    }

    public static final int MARKET_OK_FIELD_NUMBER = 6;
    private boolean marketOk_;
    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    public boolean hasMarketOk() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    public boolean getMarketOk() {
      return marketOk_;
    }
    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    private void setMarketOk(boolean value) {
      bitField0_ |= 0x00000010;
      marketOk_ = value;
    }
    /**
     * <pre>
     * If Market got the market_checkin data OK.
     * </pre>
     *
     * <code>optional bool market_ok = 6;</code>
     */
    private void clearMarketOk() {
      bitField0_ = (bitField0_ & ~0x00000010);
      marketOk_ = false;
    }

    public static final int ANDROID_ID_FIELD_NUMBER = 7;
    private long androidId_;
    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    public boolean hasAndroidId() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    public long getAndroidId() {
      return androidId_;
    }
    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    private void setAndroidId(long value) {
      bitField0_ |= 0x00000020;
      androidId_ = value;
    }
    /**
     * <pre>
     * From the request, or newly assigned
     * </pre>
     *
     * <code>optional fixed64 android_id = 7;</code>
     */
    private void clearAndroidId() {
      bitField0_ = (bitField0_ & ~0x00000020);
      androidId_ = 0L;
    }

    public static final int SECURITY_TOKEN_FIELD_NUMBER = 8;
    private long securityToken_;
    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    public boolean hasSecurityToken() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    public long getSecurityToken() {
      return securityToken_;
    }
    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    private void setSecurityToken(long value) {
      bitField0_ |= 0x00000040;
      securityToken_ = value;
    }
    /**
     * <pre>
     * The associated security token
     * </pre>
     *
     * <code>optional fixed64 security_token = 8;</code>
     */
    private void clearSecurityToken() {
      bitField0_ = (bitField0_ & ~0x00000040);
      securityToken_ = 0L;
    }

    public static final int VERSION_INFO_FIELD_NUMBER = 11;
    private java.lang.String versionInfo_;
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    public boolean hasVersionInfo() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    public java.lang.String getVersionInfo() {
      return versionInfo_;
    }
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    public com.google.protobuf.ByteString
        getVersionInfoBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(versionInfo_);
    }
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    private void setVersionInfo(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
      versionInfo_ = value;
    }
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    private void clearVersionInfo() {
      bitField0_ = (bitField0_ & ~0x00000080);
      versionInfo_ = getDefaultInstance().getVersionInfo();
    }
    /**
     * <pre>
     * NEXT TAG: 12
     * </pre>
     *
     * <code>optional string version_info = 11;</code>
     */
    private void setVersionInfoBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
      versionInfo_ = value.toStringUtf8();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBool(1, statsOk_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt64(3, timeMsec_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeString(4, getDigest());
      }
      for (int i = 0; i < setting_.size(); i++) {
        output.writeMessage(5, setting_.get(i));
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(6, marketOk_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeFixed64(7, androidId_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeFixed64(8, securityToken_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(9, settingsDiff_);
      }
      for (int i = 0; i < deleteSetting_.size(); i++) {
        output.writeString(10, deleteSetting_.get(i));
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeString(11, getVersionInfo());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, statsOk_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, timeMsec_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(4, getDigest());
      }
      for (int i = 0; i < setting_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, setting_.get(i));
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, marketOk_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(7, androidId_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(8, securityToken_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, settingsDiff_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < deleteSetting_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeStringSizeNoTag(deleteSetting_.get(i));
        }
        size += dataSize;
        size += 1 * getDeleteSettingList().size();
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(11, getVersionInfo());
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static checkin_proto.Checkin.AndroidCheckinResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(checkin_proto.Checkin.AndroidCheckinResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * The response to the device.
     * </pre>
     *
     * Protobuf type {@code checkin_proto.AndroidCheckinResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          checkin_proto.Checkin.AndroidCheckinResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:checkin_proto.AndroidCheckinResponse)
        checkin_proto.Checkin.AndroidCheckinResponseOrBuilder {
      // Construct using checkin_proto.Checkin.AndroidCheckinResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether statistics were recorded properly.
       * </pre>
       *
       * <code>required bool stats_ok = 1;</code>
       */
      public boolean hasStatsOk() {
        return instance.hasStatsOk();
      }
      /**
       * <pre>
       * Whether statistics were recorded properly.
       * </pre>
       *
       * <code>required bool stats_ok = 1;</code>
       */
      public boolean getStatsOk() {
        return instance.getStatsOk();
      }
      /**
       * <pre>
       * Whether statistics were recorded properly.
       * </pre>
       *
       * <code>required bool stats_ok = 1;</code>
       */
      public Builder setStatsOk(boolean value) {
        copyOnWrite();
        instance.setStatsOk(value);
        return this;
      }
      /**
       * <pre>
       * Whether statistics were recorded properly.
       * </pre>
       *
       * <code>required bool stats_ok = 1;</code>
       */
      public Builder clearStatsOk() {
        copyOnWrite();
        instance.clearStatsOk();
        return this;
      }

      /**
       * <pre>
       * Time of day from server (Java epoch).
       * </pre>
       *
       * <code>optional int64 time_msec = 3;</code>
       */
      public boolean hasTimeMsec() {
        return instance.hasTimeMsec();
      }
      /**
       * <pre>
       * Time of day from server (Java epoch).
       * </pre>
       *
       * <code>optional int64 time_msec = 3;</code>
       */
      public long getTimeMsec() {
        return instance.getTimeMsec();
      }
      /**
       * <pre>
       * Time of day from server (Java epoch).
       * </pre>
       *
       * <code>optional int64 time_msec = 3;</code>
       */
      public Builder setTimeMsec(long value) {
        copyOnWrite();
        instance.setTimeMsec(value);
        return this;
      }
      /**
       * <pre>
       * Time of day from server (Java epoch).
       * </pre>
       *
       * <code>optional int64 time_msec = 3;</code>
       */
      public Builder clearTimeMsec() {
        copyOnWrite();
        instance.clearTimeMsec();
        return this;
      }

      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public boolean hasDigest() {
        return instance.hasDigest();
      }
      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public java.lang.String getDigest() {
        return instance.getDigest();
      }
      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public com.google.protobuf.ByteString
          getDigestBytes() {
        return instance.getDigestBytes();
      }
      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public Builder setDigest(
          java.lang.String value) {
        copyOnWrite();
        instance.setDigest(value);
        return this;
      }
      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public Builder clearDigest() {
        copyOnWrite();
        instance.clearDigest();
        return this;
      }
      /**
       * <pre>
       * Provisioning is sent if the request included an obsolete digest.
       * For version &lt;= 2, 'digest' contains the digest that should be
       * sent back to the server on the next checkin, and 'setting'
       * contains the entire gservices table (which replaces the entire
       * current table on the device).
       * for version &gt;= 3, 'digest' will be absent.  If 'settings_diff'
       * is false, then 'setting' contains the entire table, as in version
       * 2.  If 'settings_diff' is true, then 'delete_setting' contains
       * the keys to delete, and 'setting' contains only keys to be added
       * or for which the value has changed.  All other keys in the
       * current table should be left untouched.  If 'settings_diff' is
       * absent, don't touch the existing gservices table.
       * </pre>
       *
       * <code>optional string digest = 4;</code>
       */
      public Builder setDigestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDigestBytes(value);
        return this;
      }

      /**
       * <code>optional bool settings_diff = 9;</code>
       */
      public boolean hasSettingsDiff() {
        return instance.hasSettingsDiff();
      }
      /**
       * <code>optional bool settings_diff = 9;</code>
       */
      public boolean getSettingsDiff() {
        return instance.getSettingsDiff();
      }
      /**
       * <code>optional bool settings_diff = 9;</code>
       */
      public Builder setSettingsDiff(boolean value) {
        copyOnWrite();
        instance.setSettingsDiff(value);
        return this;
      }
      /**
       * <code>optional bool settings_diff = 9;</code>
       */
      public Builder clearSettingsDiff() {
        copyOnWrite();
        instance.clearSettingsDiff();
        return this;
      }

      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public java.util.List<java.lang.String>
          getDeleteSettingList() {
        return java.util.Collections.unmodifiableList(
            instance.getDeleteSettingList());
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public int getDeleteSettingCount() {
        return instance.getDeleteSettingCount();
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public java.lang.String getDeleteSetting(int index) {
        return instance.getDeleteSetting(index);
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public com.google.protobuf.ByteString
          getDeleteSettingBytes(int index) {
        return instance.getDeleteSettingBytes(index);
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public Builder setDeleteSetting(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setDeleteSetting(index, value);
        return this;
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public Builder addDeleteSetting(
          java.lang.String value) {
        copyOnWrite();
        instance.addDeleteSetting(value);
        return this;
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public Builder addAllDeleteSetting(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllDeleteSetting(values);
        return this;
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public Builder clearDeleteSetting() {
        copyOnWrite();
        instance.clearDeleteSetting();
        return this;
      }
      /**
       * <code>repeated string delete_setting = 10;</code>
       */
      public Builder addDeleteSettingBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addDeleteSettingBytes(value);
        return this;
      }

      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public java.util.List<checkin_proto.Checkin.GservicesSetting> getSettingList() {
        return java.util.Collections.unmodifiableList(
            instance.getSettingList());
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public int getSettingCount() {
        return instance.getSettingCount();
      }/**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public checkin_proto.Checkin.GservicesSetting getSetting(int index) {
        return instance.getSetting(index);
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder setSetting(
          int index, checkin_proto.Checkin.GservicesSetting value) {
        copyOnWrite();
        instance.setSetting(index, value);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder setSetting(
          int index, checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
        copyOnWrite();
        instance.setSetting(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder addSetting(checkin_proto.Checkin.GservicesSetting value) {
        copyOnWrite();
        instance.addSetting(value);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder addSetting(
          int index, checkin_proto.Checkin.GservicesSetting value) {
        copyOnWrite();
        instance.addSetting(index, value);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder addSetting(
          checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
        copyOnWrite();
        instance.addSetting(builderForValue);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder addSetting(
          int index, checkin_proto.Checkin.GservicesSetting.Builder builderForValue) {
        copyOnWrite();
        instance.addSetting(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder addAllSetting(
          java.lang.Iterable<? extends checkin_proto.Checkin.GservicesSetting> values) {
        copyOnWrite();
        instance.addAllSetting(values);
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder clearSetting() {
        copyOnWrite();
        instance.clearSetting();
        return this;
      }
      /**
       * <code>repeated .checkin_proto.GservicesSetting setting = 5;</code>
       */
      public Builder removeSetting(int index) {
        copyOnWrite();
        instance.removeSetting(index);
        return this;
      }

      /**
       * <pre>
       * If Market got the market_checkin data OK.
       * </pre>
       *
       * <code>optional bool market_ok = 6;</code>
       */
      public boolean hasMarketOk() {
        return instance.hasMarketOk();
      }
      /**
       * <pre>
       * If Market got the market_checkin data OK.
       * </pre>
       *
       * <code>optional bool market_ok = 6;</code>
       */
      public boolean getMarketOk() {
        return instance.getMarketOk();
      }
      /**
       * <pre>
       * If Market got the market_checkin data OK.
       * </pre>
       *
       * <code>optional bool market_ok = 6;</code>
       */
      public Builder setMarketOk(boolean value) {
        copyOnWrite();
        instance.setMarketOk(value);
        return this;
      }
      /**
       * <pre>
       * If Market got the market_checkin data OK.
       * </pre>
       *
       * <code>optional bool market_ok = 6;</code>
       */
      public Builder clearMarketOk() {
        copyOnWrite();
        instance.clearMarketOk();
        return this;
      }

      /**
       * <pre>
       * From the request, or newly assigned
       * </pre>
       *
       * <code>optional fixed64 android_id = 7;</code>
       */
      public boolean hasAndroidId() {
        return instance.hasAndroidId();
      }
      /**
       * <pre>
       * From the request, or newly assigned
       * </pre>
       *
       * <code>optional fixed64 android_id = 7;</code>
       */
      public long getAndroidId() {
        return instance.getAndroidId();
      }
      /**
       * <pre>
       * From the request, or newly assigned
       * </pre>
       *
       * <code>optional fixed64 android_id = 7;</code>
       */
      public Builder setAndroidId(long value) {
        copyOnWrite();
        instance.setAndroidId(value);
        return this;
      }
      /**
       * <pre>
       * From the request, or newly assigned
       * </pre>
       *
       * <code>optional fixed64 android_id = 7;</code>
       */
      public Builder clearAndroidId() {
        copyOnWrite();
        instance.clearAndroidId();
        return this;
      }

      /**
       * <pre>
       * The associated security token
       * </pre>
       *
       * <code>optional fixed64 security_token = 8;</code>
       */
      public boolean hasSecurityToken() {
        return instance.hasSecurityToken();
      }
      /**
       * <pre>
       * The associated security token
       * </pre>
       *
       * <code>optional fixed64 security_token = 8;</code>
       */
      public long getSecurityToken() {
        return instance.getSecurityToken();
      }
      /**
       * <pre>
       * The associated security token
       * </pre>
       *
       * <code>optional fixed64 security_token = 8;</code>
       */
      public Builder setSecurityToken(long value) {
        copyOnWrite();
        instance.setSecurityToken(value);
        return this;
      }
      /**
       * <pre>
       * The associated security token
       * </pre>
       *
       * <code>optional fixed64 security_token = 8;</code>
       */
      public Builder clearSecurityToken() {
        copyOnWrite();
        instance.clearSecurityToken();
        return this;
      }

      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public boolean hasVersionInfo() {
        return instance.hasVersionInfo();
      }
      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public java.lang.String getVersionInfo() {
        return instance.getVersionInfo();
      }
      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public com.google.protobuf.ByteString
          getVersionInfoBytes() {
        return instance.getVersionInfoBytes();
      }
      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public Builder setVersionInfo(
          java.lang.String value) {
        copyOnWrite();
        instance.setVersionInfo(value);
        return this;
      }
      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public Builder clearVersionInfo() {
        copyOnWrite();
        instance.clearVersionInfo();
        return this;
      }
      /**
       * <pre>
       * NEXT TAG: 12
       * </pre>
       *
       * <code>optional string version_info = 11;</code>
       */
      public Builder setVersionInfoBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVersionInfoBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:checkin_proto.AndroidCheckinResponse)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new checkin_proto.Checkin.AndroidCheckinResponse();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasStatsOk()) {
            return null;
          }
          for (int i = 0; i < getSettingCount(); i++) {
            if (!getSetting(i).isInitialized()) {
              return null;
            }
          }
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          deleteSetting_.makeImmutable();
          setting_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          checkin_proto.Checkin.AndroidCheckinResponse other = (checkin_proto.Checkin.AndroidCheckinResponse) arg1;
          statsOk_ = visitor.visitBoolean(
              hasStatsOk(), statsOk_,
              other.hasStatsOk(), other.statsOk_);
          timeMsec_ = visitor.visitLong(
              hasTimeMsec(), timeMsec_,
              other.hasTimeMsec(), other.timeMsec_);
          digest_ = visitor.visitString(
              hasDigest(), digest_,
              other.hasDigest(), other.digest_);
          settingsDiff_ = visitor.visitBoolean(
              hasSettingsDiff(), settingsDiff_,
              other.hasSettingsDiff(), other.settingsDiff_);
          deleteSetting_= visitor.visitList(deleteSetting_, other.deleteSetting_);
          setting_= visitor.visitList(setting_, other.setting_);
          marketOk_ = visitor.visitBoolean(
              hasMarketOk(), marketOk_,
              other.hasMarketOk(), other.marketOk_);
          androidId_ = visitor.visitLong(
              hasAndroidId(), androidId_,
              other.hasAndroidId(), other.androidId_);
          securityToken_ = visitor.visitLong(
              hasSecurityToken(), securityToken_,
              other.hasSecurityToken(), other.securityToken_);
          versionInfo_ = visitor.visitString(
              hasVersionInfo(), versionInfo_,
              other.hasVersionInfo(), other.versionInfo_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  bitField0_ |= 0x00000001;
                  statsOk_ = input.readBool();
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000002;
                  timeMsec_ = input.readInt64();
                  break;
                }
                case 34: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000004;
                  digest_ = s;
                  break;
                }
                case 42: {
                  if (!setting_.isModifiable()) {
                    setting_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(setting_);
                  }
                  setting_.add(
                      input.readMessage(checkin_proto.Checkin.GservicesSetting.parser(), extensionRegistry));
                  break;
                }
                case 48: {
                  bitField0_ |= 0x00000010;
                  marketOk_ = input.readBool();
                  break;
                }
                case 57: {
                  bitField0_ |= 0x00000020;
                  androidId_ = input.readFixed64();
                  break;
                }
                case 65: {
                  bitField0_ |= 0x00000040;
                  securityToken_ = input.readFixed64();
                  break;
                }
                case 72: {
                  bitField0_ |= 0x00000008;
                  settingsDiff_ = input.readBool();
                  break;
                }
                case 82: {
                  java.lang.String s = input.readString();
                  if (!deleteSetting_.isModifiable()) {
                    deleteSetting_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(deleteSetting_);
                  }
                  deleteSetting_.add(s);
                  break;
                }
                case 90: {
                  java.lang.String s = input.readString();
                  bitField0_ |= 0x00000080;
                  versionInfo_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (checkin_proto.Checkin.AndroidCheckinResponse.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:checkin_proto.AndroidCheckinResponse)
    private static final checkin_proto.Checkin.AndroidCheckinResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new AndroidCheckinResponse();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static checkin_proto.Checkin.AndroidCheckinResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AndroidCheckinResponse> PARSER;

    public static com.google.protobuf.Parser<AndroidCheckinResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
